
================================================================
1. ReactJs JS Intro & Workspace Setup
================================================================
Series: https://www.youtube.com/watch?v=MhkGQAoc7bc&list=PLoYCgNOIyGABj2GQSlDRjgvXtqfDxKm5b
GitHub: https://github.com/learncodeacademy/react-js-tutorials



*****************************************
Video 01: ReactJS Intro & Workspace Setup
*****************************************
https://youtu.be/MhkGQAoc7bc
----------------------------------------
About
----------------------------------------
REACT changes way you think...
Concepts introduced to creating stable web apps.
Prerequisites:
	ES6
	WebPack
.
	
----------------------------------------
Info
----------------------------------------
Got files from github...
	webpack
	webpack --watch
		as we save, client.min.js gets updated
React basics/methodology
	* "AS everything is an element in HTML," 
	* "everything is a component in React"
	* "rendering engine is Separate from react syntax!"
	import
		import React from "react";
			can render to many things
		import ReactDOM from "react-dom";
			*! rendering engine to dom aka our active webPage
	Creating Component Structure
		class file extends React Component
		need render method in component	
			render(){return (//JSX here); }
		if ever want to render a component...
			use it as if an html tag
			ReactDOM.render(<Layout/>, app); //forward-slash necessary? 
				renders `Layout` component in app div
//OLD
var div = document.createElement("div");
div.innerHTML = "some content";
//NEW
	//Where Layout is a class component.
const app = document.getElementById('app');
ReactDOM.render(<Layout/>, app);

Live reloading
	some IDEs have this, 
	but `webpack-dev-server` may be better 
		so page rendered from webpack output file directly.

global to local with npm's run scripts.
//OLD
	`npm install -g webpack-dev-server`
	`webpack-dev-server` etc...
//NEW
	`npm install -D webpack-dev-server` OR `npm install -S webpack-dev-server`
	inside package.json's... 'scipts': {"subCommand": "cmdLn"} 
		apply something similar as below:
		"./node_modules/.bin/webpack-dev-server" -flagsIfNeeded
.

*****************************************
Video 02: Reactjs Components & Rendering
*****************************************
https://youtu.be/fd2Cayhez58
----------------------------------------
About
----------------------------------------
Should be set up.
Everything in REACT is a component.
*Components return exactly one DOM element.
	like HTML, everything must have one parent DOM element.	

-----------------------------
1 DOM Element + more via div
-----------------------------
class Layout extends React Component {
	render(){
		return (
			<div>//CORRECT 
				<h1>It is working!</h1>
				//<h1>It is working!</h1> //INCORRECT //if placed another element here, would error out.
				<h1>It is working!</h1>
			</div>
		);
	}//render
}//Layout Component
//render component into app div.
const app = document.getElementById("app");
ReactDOM.render(<Layout/>, app);

-----------------------------
Dynamic
-----------------------------
class Layout extends React Component {
		//Best to place logic outside render!
	constructor (){
		super();
		this.name1 = "will";
	}
	
	getVal(){
		return "James";
	}
	
	render(){
		const name = "Will";
			//Place logic outside return!
		return (
				<h1>{this.getVal()}, it is working for { name } and {this.name1}!</h1>
			</div>
		);
	}//render
}//Layout Component
//render component into app div.
const app = document.getElementById("app");
ReactDOM.render(<Layout/>, app);


	
*****************************************
Video 03: Composing Multiple React.js Components
*****************************************
https://youtu.be/vu_rIMPROoQ
----------------------------------------
About
----------------------------------------
Move out of single component
Move into entire Layout made of React components

----------------------------------------
Design
----------------------------------------
`client.js`
	import React from "react";
	import ReactDOM from "react-dom";
	
	//The overall component.
	import Layout from "./components/Layout";

	const app = document.getElementById('app');
	ReactDOM.render(<Layout/>, app);
//Keep component in its own folder

`Layout.js`
	import React from "react.js"
	import Footer from "Footer.js";
	import Header from "Header.js";

	export default class Layout extends React Component {
		constructor(){
			super();
			this.name = "Will";
			this.list = [
				<li>,
				<li>,
				<li>,
			];
			
		}//constructor
		
		render(){
			var attribute = "cool";
			return (
				<div>
					<Header />
					<ul>This is {this.name}'s unordered {attribute} list.
						{this.list}
					</ul>
					<Footer />
				</div>
			);
		}//render		
		
	}//class - Layout
//I coudn't create a variable in the class itself and called within render's return.
//2 places I can are: class's constructor & render().
//Keep imports alphabetized for easy lookup.

`Header.js` & ~Footer.js
import React from "react";
export default class Header extends React Component {
	render(){
		return (
			<footer>footer</footer>
		);
	}
}
//above is just a display for the above's imports of Header&Footer
................................................
----------------------------------------
Summary
----------------------------------------
To avoid getting messy in the main js file, the main js file only job may be to render the main component.
The main component can have the overall set up the other components.
Break down all the components to the smallest possible.
A component may use the other components by 
	importing.
	Using tag via class name. Similar to XML custom tag defining.
Next time...
	Passing values into components--many ways.
		-One was covered, but not explained in video 3 via using class components and JSX.
		-more?...



*****************************************
Video 04: State vs Props & Application Data
*****************************************
https://youtu.be/qh3dYM6Keuw
----------------------------------------
About
----------------------------------------
* How Data is managed in React.
1st great feature of react.

2 ways data gets handled.
1. state
2. props
3. context - but, this is an advanced feature. Also, API is not stabilize guaranteed. 

----------------------------------------
State
----------------------------------------
this.state = null; //by default.
*Manages a VIRTUAL DOM
	-when state changes on a component, component will re-render.
	-doesn't touch DOM until Virtual DOM is.
	-whenever React renders component tree, it looks for changes in Virtual DOM to actual DOM.
*WHY IS IT GREAT!
	-JavaScript is fast, DOM is slow. 
	-Whenever, need to update DOM, that is the slowest part.
	-my tidbit: this is similar to what is said about JQuery, and you had to manually be wary of not editing DOM when there was no need to.
		-kinda like Java String Builder, no changes or objects/strings/etc made until it is finalized.
WHAT IS REACT DOING BEHIND SCENES.
	*On Chrome's console, click `escape` key for rendering options.
		-enable paint flashing
			this helps to see which parts of DOM changes.
	React manages DOM
	//OLD Qs
		When should I update DOM?
		When I do, who should? - list component or each list item render itself.
	//New Solution
		Re-render everything, all the time, on any change, but only in JS, only touch DOM if something changed visually.
MENTALLITY of STATE
	state only gets used, if component has an internal value that only affects that component.
		When to use?
			If you have something that only affects a certain component
		Otherwise used props.
.

//in a class component's constructor
constructor (){
	super();
	this.state = {name: "Will"};
}
render(){
	setTimeout( () => {
		//say user fired some action, this action.
		this.setState({name: "Bob"});
	}, 1000);
	return(
		<div>
			{this.state.name}
		</div>
	);
}
	
----------------------------------------
Props *more popular.
----------------------------------------
this.props.[]
* props are injected into every other components.
They are basically the attributes of an element
As props are to that of a Component.

`Layout.js` with prop
	import React from "react";

	import Footer from "./Footer";
	import Footer from "./Header";

	export default class Layout extends React Component {
		render(){
			const title = "Welcome Will!";
			return(
				<div>
					<Header name={"Thing1"} title={title} />
					<Header name={"Thing2"} title={title} />
				</div>
			);
		}
	}
//notice how props were inject with curly braces as a variable and a value.
//Can create another component and insert props, change values, etc.
	//Acts like an XML of JavaScript in JSON for states and is customizable constructor-like, but not really.
.

`Header.js` designed with above
	import React from "react";

	//importing other components
	import Footer from "./Header/Title";

	export default class Header extends React Component {
		render(){
			//console.log(this.props);
			return(
				<div>
					<Title title={this.props.title} /> //!!!
					
				</div>
			);
		}
	}//Component
//notice title props in Title component tag.
//it act as if it is waiting if a title prop, in props, was passed via a call of the component in another component. Doesn't know what props are going to be passed.
//Acts more like C++'s variable passing hierarchy where the 3rd class, extending a 2nd class that extends the 1st class, needs to pass a value to the 2nd class that will capture that variable (not value) and pass it into 1st class's variable.
[class 1] var1 = 1
[class 2] var2 = var1
[class 3] var3 = var2
.
`Title.js` designed with above
	import React from "react";

	export default class Title extends React Component {
		render(){
			//console.log(this.props);
			return(
				<div>
					<h1>title={this.props.title} </h1> //!!!
				</div>
			);
		}
	}//Component
.
//Basically "transparently" passing value through.
.
.
.
----------------------------------------
Mixing Props and States
----------------------------------------
`Layout.js`
	import React from "react";

	import Footer from "./Footer";
	import Footer from "./Header";

	export default class Layout extends React Component {
		constructor (){
			super();
			this.state = {
				title: "Nice to meet you."
			};
		}
		render(){
			const title2 = "Welcome Will!";
			setTimeout( () => {
				this.setState({title: "Welcome Will!"});
			}, 2000);
			return(
				<div>
					<Header name={"Thing1"} title={this.state.title} />
					<Header name={"Thing2"} title={title2} />
				</div>
			);
		}
	}
.
//WHAT HAPPENED W/ MIX?
	Did what was expected.
		It showed components and the change after 2 sec. ~ to state prob.
//WHAT GOT UPDATE?
	Only header component changed.
	Though variable passed to Layout, change occurred in Header's div. To be more precise, the Title component itself lying within Header.
.
.
.................................
`Header.js`
	import React from "react";

	//importing other components
	import Footer from "./Header/Title";

	export default class Header extends React Component {
		render(){
			//console.log(this.props);
			return(
				<div>
					<Title title={this.props.title} /> //!!!
					
				</div>
			);
		}
	}//Component
.
.
.................................
`Title.js` designed with above
	import React from "react";

	export default class Title extends React Component {
		render(){
			//console.log(this.props);
			return(
				<div>
					<h1>title={this.props.title} </h1> //!!!
				</div>
			);
		}
	}//Component
.

----------------------------------------
Summary
----------------------------------------
**look in 'About'

	
*****************************************
Video 05: Events & Data Changes in React
*****************************************
https://youtu.be/_D1JGNidMr4
----------------------------------------
About
----------------------------------------
binding events
interacting with User input
Changing data real-time
	
----------------------------------------
input
----------------------------------------
.
//As input header gets typed, will want to trigger an event in layout to update the layout's state.
.
.
...........................
`Layout.js`
import React from "react";

import Footer from "./Footer";
import Footer from "./Header";

export default class Layout extends React Component {
	constructor (){
		super();
		this.state = {
			title: "Welcome",
		};
	}
	
	//!!!
	changeTitle(title){
		this.setState({ title });		
	}
	
	render(){
		const title2 = "Howdy Yall!";
		return(
			<div>
				<Header name={"Thing1"} changeTitle={this.changeTitle.bind(this)} title={this.state.title} />
				
				<Header name={"Thing2"} title={title2} />
			</div>
		);
	}
}
.
//VERY IMPORTANT:
	When passing around methods, ALWAYS bind them to 'this'.
	If don't do `.bind(this)`, will execute in context to whoever is calling it.
		my tidbit: existence critical override.
		ex: 
			in Header, if did this: this.props.changeTitle();
			It is like calling the method in Header, which may/may not exist, and executing it.
			this.setState({ title }), is ran and is silent failure. Like what happens with 'use strict'.
.
.
...............................
Edit `Header.js` w/ variation

handleChange(e){
	const title = e.target.value;
	this.props.changeTitle(title);
}
render(){
	return(
		<div>
			//<h1>title={this.props.title} </h1>
			<Title title={this.props.title}> </Title>
			<input onChange={this.handleChange.bind(this)} />
		</div>
	);
}
.
//added input and an onChange prop to input
//handleChange receives an event like normal
//events: onChange, onClick, onBlur
//!! on event, fires this into the function be called to handle.
//*!! if you are writing in an input and nothing happens on screen , like characters not showing. Might mean you need to check if even prop has been included.
.
.
.
.................................
`Title.js` is the same...
import React from "react";

export default class Title extends React Component {
	render(){
		return(
			<div>
				<h1>title={this.props.title} </h1> //!!!
			</div>
		);
	}
}//Component
.
.
----------------------------------------
Summary
----------------------------------------


/*--*//*--*/
SEE OVERVIEW SECTION TO REVIEW 1-5



.
.
.
*****************************************
Video 06: React Router & Intro to Single Page Apps with React 
*****************************************
https://youtu.be/1iAG6h9ff5s
GitHub: I think this is when second folder is finally used. "2-react-router"
----------------------------------------
About
----------------------------------------
-single page apps.
-try not leave people behind.
-not too slow/beginner for those experienced with Angular, Backbone, Ember, [other single page application frameworks] etc.
*Shows how to make 1st few Routes, 
	THEN, break page out in the next video
.

----------------------------------------
Info from presenter
----------------------------------------
*Single page application:: navigate + everything else, without leaving page.
Wanted more then boring HTML, so went to 
	*Bootstrap.com
		got basic theme.
	*stripped out jquery
	*Bootswatch for a different CSS theme.
	Bootstrap WithoutJQuery.js GitHub repository.
		lightweight script to replace JQuery. 
		for simple things like, drop downs, hamburger icons, etc.
Result: 
	an long html page designed for certain purpose.
	still has everything from last folder (videos [1-5])
		bootstrap
		client.min.js
		div id="app"
Files
`client.js`
	same -- for the most part. 
		loading/importing layout, binding id app, and rendering it.
	new
		loading/importing Bootstrap without js.
*Routing:: 
	This is where when you click on buttons, can route to different pages/states of the application wo/leaving the page via JS.
IMPORTANT UPDATE ON NPM Script:
	Recap:
		>>npm run script to {"dev": "./node_modules/bin/webpack-dev-server"}
	Can do:
		without calling within node_modules in place of global installation.
		>>npm run script to {"dev": "webpack-dev-server"}
			Why?
				automatically adds "./node_modules/.bin/"<path>
				What I know:
					If i remember right and if for the same reason, 
						a command within the directory can search in tree of node_modules, node_modules inside node_modules inside etc.
.
Library Usage to pay attention to...
Bootstrap HTML
{Router, Route, IndexRoute, hashHistory, Link} from react-router
	-in RENDER
	Router is like the base REST to components
		is given prop.history={hashHistory}
		hashHistory
			seems to be a collection of functions.
	Route is like the REST to components
		props to pass: path, component
	IndexRoute
		default index route.
		is like the slash to introduce sub-routes
	Link
		same as anchor
		prop: to
	The Unexplained
		props.children
			probably from Routes
			value is the Route we clicked on
.	
----------------------------------------
Steps
----------------------------------------
//! not covered, just follow the vid....
Will be converting static HTML to dynamic.
	KillerNews.net was the only dynamic bit.
01. Set up Routing
	`npm install -S react-router history@1`
	TIP: copy 2-react-router folder from repo
02. Edit `client.js`
	added Router and 1st Route
03. Create React Components for each 'page'
	Featured
	Archives
	Settings
04. Import 'page' into client
05. Edit `client.js`
	added IndexRoute for Featured
	Then, Route for each 'page' w/path
06. Edit `Layout.js`
	link pages and add button design.
	Add button w/ event
		`navigate` event
			print props
			use props.history methods
				.pushState(null, "")
				.replaceState(null, "")
.
----------------------------------------
`client.js`
----------------------------------------
import Bootstrap from "./vendor/bootstrap-without-jquery";
import { Router, Route, IndexRoute, hashHistory} from "react-router";

//Pages aka IndexRoute aka sub-routes
import Archives from "./pages/Archives";
import Featured from "./pages/Featured";
import Layout from "./pages/Layout";
import Settings from "./pages/Settings";

//instead of rendering Layout, we render our router
	//AND render all our ROUTES, and point them to different components.
ReactDOM.render(
	<Router history={ hashHistory } > //all it takes to officially have react-router running.
		<Route path="/" component={Layout}></Route>
			<IndexRoute component={Featured} ></IndexRoute>
			<Route path="archives" component={Archives} ></Route> //will be passed to 1st Route as props.children
			<Route path="settings" component={Settings} ></Route>
	</Router>,
app);
.
.
----------------------------------------
`Layout.js`
----------------------------------------
//instead of <a href="">, we will use Link
import { Link } from "react-router";
navigate (){
	console.log(this.props);//display in console of my props //STUFY THE PROPS TO KNOW WHAT WAS POSSIBLY PASSED BY CLIENT.
	this.props.history.pushState(null, "/");
	//this.props.history.replaceState(null, "/"); //Makes person stay and not go back.
}
render(){
	return(
		<div>
			<h1>KillerNews.net</h1>
			{this.props.children}
			<Link to="archives"><button class="btn btn-success">archives</button></Link>
			<Link to="settings"><button class="btn btn-success">settings</button></Link>
			<button onClick={this.navigate.bind(this)} >featured</button>
		</div>
	);
}
.
.
.
*****************************************
Video 07: React Router Params & Queries
*****************************************
https://youtu.be/ZBxMljq9GSE
----------------------------------------
About
----------------------------------------
Before covering:
	Complicated Data: Flux, Redux, 
Will cover:
	more Routing features
	handling
		Routes
		Route info
	Getting All HTML into React App.
.
----------------------------------------
Info
----------------------------------------
Specific/Detailed Routing
	params w/ optional using '()'
		this.props.params
		ex: archives/"someArticle/someFilter"
		can add what is called "params" ex:':article' to end of Route's path prop
			<Route path="archives(/:article)" name="archives" component{Archives}></Route>
	location.query
		this.props.location.query
Dynamic attributes.
	I think this is like CSS's active link styling, but/or dynamically adds a class by page/click.
	*method 1: Link Prop
		activeClassName="test"
	method 2: manual JS
		history.isActive("archives") //maybe only with Links
			returns boolean
After Setting up Routes, Links, etc.
He decided to bring components in.
What he did...
	Break down the page into components that are placed into Layout.
	ex: navigation into Layout as navigation component

SUGGESTION
	Play with React & Routing before moving on...
	My tidbit: 
		react-router: https://www.npmjs.com/package/react-router
.
.
.
----------------------------------------
`Layout.js`
----------------------------------------
<Link activeClassName="classNameForStylePurpose" to="archives" ></Link>
.
----------------------------------------
`Archives.js`
----------------------------------------
export default class Archives extends React Component {
	render(){
		console.log(this.props);
		const { query } = this.props.location;
		const { article } = this.props.params;
		return (
			<div>
				<h1>Archives {article}</h1>
				<h4>date: {date}, filter: {filter}</h4>
			</div>
		);
	}
}
.	
----------------------------------------
`client.js`
----------------------------------------
<Route path="archives(/:article)" name="archives" component{Archives}></Route>
.
.
.
.
*****************************************
Video 08: React Inline Styles & Component Arrays
*****************************************
https://youtu.be/XVdwq8W2ZsM
----------------------------------------
About
----------------------------------------
100% of static HTML is now in React App.
instead of 30min video of ctrl+C & ctrl+P,
	walk through the code.
Will explain react tricks he learned.
Shows how got rid of 
	'import Bootstrap from "./vendor/bootstrap-without-jquery"'
THEN, get into flux in next video.


----------------------------------------
Info / Walk-through
----------------------------------------
.....................
IN `Layout.js`
.....................
components imported: 
	Nav, Footer
Rendered children in the middle
	{this.props.children}
Everything else in Top page components
	ex:Archives, Featured, Settings
1 style
	<div class="container" style{containerStyle} >
	How?
		In-line :[
		const containerStyle = {
			marginTop: "60px"
		}
	IF, too long.
		break into own styleSheet.

.
.....................
IN `Nav.js`
.....................
Simply place static HTML.
	events converted if needed.
	navbar class name given a variable dynamic name of a ternary const evaluated by this.state.collapsed
	li class are pathParms for active buttons
*HOW CAN YOU USE `class` IN JSX AREA?*
	In React should be using `className`. 
		remember other video
	`class` is a JS reserved word.
	with webpack plugin
		'react-html-attrs'
			transpiles class to className
	This allow strait copy/paste of Bootstrap.
HOW WAS ABLE TO TOGGLE BUTTON?
	In constructor, this.state.collapsed=true;
	button type="button" class="navbar-toggle" onClick={this.toggleCollapse.bind(this)}
	toggleCollapse(){
		const collapsed = !this.state.collapsed;
		this.setState({collapsed});
	}
HOW GOT RID OF Bootstrap wo/ JQuery? HOW 100% React?
	Converted JQuery to JS.
	says no "Bootstrap on page"...?
	Basically everything above in this file section.
.
.....................
IN `Featured.js`
.....................
Articles are Semi-Dynamic
	const randomAd = adText[Math.round( Math.random() * (adText.length-1) )]
	{randomAd}
	<div class="row">{Articles}</div>
HOW TO MAKE MANY ARTICLES?
	//INCORRECT - gives warning, cause wants unique keys of each same component.
const Articles = [
	<Article key={1} title{"some title"} />
	<Article key={2} title{"some title"} />
	<Article key={3} title{"some title"} />
];
	//CORRECT
const Articles = [
	"some title1",
	"some title2",
	"some title3",
].map( (title, i) => <Article key={i} title={title} /> );
	//CHECK HOW MAP & Maps CallBack params works...
BOOTSTRAP DOES AMAZING JOB WITH SPACING CONTENT.
.
.
.
*****************************************
Video 09: React Flux Introduction & Flux Stores
*****************************************
https://youtu.be/PvjNglsyOHs
----------------------------------------
Info
----------------------------------------
Flux
	is not framework
	is a pattern that FB lay-ed out for building react frameworks.
React 
	is just a view layer
	doesn't provide a way to manage data. 
	allows prop injection into components
	doesn't have a 'framework', can provide it one.
Flux Pattern
	*see video image.
	it is a loop
		Components->Actions->Dispatcher->Stores
	Where 'Constants' connects Actions and Stores
.
Explained...
React Components 
	do 2 things
	1. Fire Actions
		Actions handles actions
	2. Listen to Stores
		when store updates, receives an event & updates
	- Can query a store 
Actions
	Pipe actions to Dispatcher
Dispatcher
	Basically a PubSub (pattern of communication)
		Pubsub every module can subscribe to specific set of event(s) & notify when event takes place.
	Except that it, dispatcher takes every event and sends to every subscriber.
Store
	stores gets every event from dispatcher
	only reacts to events it cares about.
.
Why is this good? - seems redundant...
	-gives everybody the chance to, change/re-render when anything changes
	-Virtual DOM always changes, but DOM ONLY changes when it visually changes.
	DOM is slower than VDOM.
----------------------------------------
Summmary:
----------------------------------------
Dom is slowest part of JS app.
Components fire actions.
Actions only aware of Dispatcher.
Dispatcher aware of everyone who needs to hear about actions (given all actions).
Stores decides to ignore actions or update themselves. Also, fire update events showing TODO list changed, and then...
Component listening to certain stores updated themselves and re-render app. 
Constants -- used by some frameworks -- a way of storing action names. 
.
.
.
*****************************************
Video 10: Flux Store Events
*****************************************
https://youtu.be/bvEC6i7CUyE
----------------------------------------
About
----------------------------------------
"Sorry babe I wasn't listening, I was too busy...
fixing my flux dispatcher, 
you see it wasn't emitting the constants to the storage properly.
"
^Many new words to JS...confusing...
Just learn the meaning.

Flux/etc Easy after understand word meaning.
Hard to understand when people forget how hard it is when never having heard words before and they trying communicating it to you.

*Build Dispatcher next video

Where are we so far, 
	we have our component pulling data from Store--not so dynamic.

We need better, 
	dynamic aspect by, 
	when store changes, it emits a change method and Component can stay updated as Store changes. 

----------------------------------------
files Abridged
----------------------------------------

.....................
	IN `Component.js`
.....................
import Store from "Store.js"; //Data location
export default class ComponentName extends React.Component {
	constructor(){
		this.state = {
			data: Store.getAll(), //safe way to get data
		};
	}
	//*see note**
	componentWillMount(){
		Store.on("change", () => {
			this.setState({ data: Store.getAll() });
		});
	}
}

.....................
	Note
.....................
Store must react when receives an event to change.
	store.on("change", someHandler);
EventEmitter comes with nodeJS.

componentWillMount()
	//Is part of React.Component
	//whenever a component will render for 1st time, will fire componentWillMount function.
	//this is great place to add event listeners, because only need to do it when it gets rendered, and only need to do it once. 

Whenever Store changes, 
	update Component's state *see componentWillMount
Can test by, 
	expose Store globally
.....................
	console / file
.....................
*window.store = Store; //store

//console
store.createStore("test store");
.
.
.
.....................
	IN `Store.js`
.....................
import { EventEmitter } from "events"; //*see note
class Store extends EventEmitter {
	constructor (){
		this.state = {
			store: [ 
				{}, 
				{id: 123, text: "Go Shop", complete: false}, 
			],
		};
	}
	getAll(){return this.state;}
	createData(){
		const id = Date.now();
		this.state.push({id, text, complete: false,});

		//emitt a change event
		this.emit("change");
	}
}
const store = new Store;
export default store;
.
.
.
----------------------------------------
	Files 'Long' Version
----------------------------------------
.....................
	IN `Component.js`
.....................
import Store from "Store.js"; //Data location
export default class ComponentName extends React.Component {
	constructor(){
		super();
		this.state = {
			data: Store.getAll(), //safe way to get data
		};
	}
	//*see note**
	componentWillMount(){
		Store.on("change", () => {
			this.setState({
				data: Store.getAll(),
			});
		});
	}
	render (){
		//renderVars&JSX
		return (
		);
	}
}

.....................
	Note
.....................
Store must react when receives an event to change.
	store.on("change", someHandler);
EventEmitter comes with nodeJS.

componentWillMount()
	//Is part of React.Component
	//whenever a component will render for 1st time, will fire componentWillMount function.
	//this is great place to add event listeners, because only need to do it when it gets rendered, and only need to do it once. 

Whenever Store changes, 
	update Component's state *see componentWillMount
Can test by, 
	expose Store globally
.....................
	console / file
.....................
*window.store = Store; //store

//console
store.createStore("test store");

.....................
	IN `Store.js`
.....................
import { EventEmitter } from "events"; //*see note
class Store extends EventEmitter {
	constructor (){
		super();
		this.state = {
			store: [
				{
					id: 123,
					text: "Go Shop",
					complete: false
				}, 
				{
					id: 321,
					text: "Pay Bills",
					complete: false
				},
			],
		};
	}
	getAll(){ //safely obtain data
		return this.state;
	}
	createData(){
		const id = Date.now(); //just a hacked together unique-ish ID
		this.state.push({
			id,
			text,
			complete: false,
		});
		//emitt a change event
		this.emit("change"); //onChange, someone else can get that event.
	}
}
const store = new Store;
export default store;


*****************************************
Video 11: The Flux Dispatcher
*****************************************
https://youtu.be/MZfCVq5iCBw
----------------------------------------
About
----------------------------------------
Where are we so far, 
	component pulling initial data from Store.
	listening to Store and updating when it changes.
We need, 
	add Dispatcher
	register out store to dispatcher
	so, any actions that go through pipeline, store is notified. 
*Actions - Next video
**
**
`npm install -S flux`




----------------------------------------
	IN `Dispatcher.js`
----------------------------------------
import { Dispatcher } from "flux";
export default new Dispatcher;

----------------------------------------
	Edit `Store.js`
		is in Store folder
----------------------------------------
	import dispatcher from "../Dispatcher"
	//before export default & after object
	
	//**
	dispatcher.register(Store.handleActions.bind(Store));//to test

	//handles dispatcher.dispatch({type: "CREATE_TODO", text: "new store" });
	handleActions(action){
		//console.log("Store received an action--anything dispatcher.dispatch-ed", action);
		switch(action.type){
			case "CREATE_TODO": {
				this.createStore(action.text);
			}
		}
	}
.

----------------------------------------
	Note
----------------------------------------
dispatcher
	Only 2 methods you use
	1. dispatcher.register
		to register new listener, which is our Store
	2. dispatcher.dispatch
		what all actions will use to dispatch
		//*see Store
To test
`window.dispatcher = dispatcher;`
//console
dispatcher.dispatch({type: "Some Event"});
.
NOTICE:
	handleActions is given all actions.
	So need to get only the one we care about...
.
.
.
.
*****************************************
Video 12: Flux Actions
*****************************************
https://youtu.be/0yW7C22ooos
----------------------------------------
About
----------------------------------------
We got
	Dispatcher dispatching actions to those listening aka Store
	Store updates itself and dispatches a change event.
	Component can listen to, if want to.
Seems like lots of steps...
	As app grows, varying actions, 
	Stores only listen to Actions care about
	Components only listen to Stores care about
		and fire handful of Actions
	-this is a highly-decoupled framework
Doing now
	Action part of Flux
Next time
	Async Actions!
		ex: load from backEnd API, then show data.
		*This was my first Question!
----------------------------------------
	file `ComponentActions.js` 
		is in Actions folder
----------------------------------------
//all we have to do is dispatch actions
import dispatcher from "./dispatcher";

//ES6 way
export function createComponent(text){
	dispatcher.dispatch({
		type: "CREATE_TODO", 
		text,
	});
}
export function deleteComponent(id){
	dispatcher.dispatch({
		type: "DELETE_TODO", 
		id,
	});
}
//
//
//
//in JS would need to export function within object
export default {
	createComponent: function (){
		
	}
}
.
----------------------------------------
	In `Component.js`
----------------------------------------
import * as ComponentActions from "./Actions/ComponentAction";

createComponent(){
	ComponentActions.createComponent(Date.now());
}

//inside the Component's render return
<button onClick={this.createComponent.bind(this)}>Create!</button>
//
//
//
//Can make the button into input. //below input isn't finished.
<input onClick={this.createComponent.bind(this)}></input>
.
.
.
*****************************************
Video 13: Asynchronous & AJAX Flux Actions
*****************************************
https://youtu.be/CuYd9uDB0vg
----------------------------------------
About
----------------------------------------
1st question for people learning flux:
	w/ actions, seems great for synchronous actions, but what about Asynch actions?
		ex: load data from another page, and then an action when loading is done to display data.

----------------------------------------
	File `Component.js`

----------------------------------------
//ignore state code below
this.state = {
	data: Store.getAll(),
};

//do something when an action comes in.--only have this videos case here.
handleActions(action){
	switch(action.type){
		case "GOT_DATA": {
			//this.recieveComponent(data);
			this.data = action.data;
			this.emit("change");
		}
	}
}

//change createComponent to ReloadComponent
reloadComponent(){
	ComponentActions.reloadComponent();
}
//in button JSX
<button onClick={this.reloadComponent.bind(this)}>Reload!</button>
----------------------------------------
	File `ComponentActions.js`
		**Promise/Async
----------------------------------------
//We want app notified when data is passed. How do we do this?
export function reloadComponent (){
	URL = "http://url.com/data";
	axios(URL).then( (data) => {
		console.log("Got data!", data);
	});

	//can fake this but setting a timeout();

	//dispatch multiple events
	dispatcher.dispatch({type: "FETCH_DATA",});
	setTimeout( () => {
		dispatcher.dispatch({type: "GOT_DATA", data: [
			{},
			{data: "some data", moreData: "some more data"},
		]});
		
		//let say some prob occurred
//		if (false){
//			dispatcher.dispatch({type: "FETCH_DATA_ERROR", text: error});
//		}
	}, 1000);
}


----------------------------------------
Summary! - needed, kinda confusing...
----------------------------------------



*****************************************
Video 14: 
*****************************************


----------------------------------------

----------------------------------------



----------------------------------------

----------------------------------------



*****************************************
Video 15: How Redux Works - Redux Tutorial #1
*****************************************
https://youtu.be/1w-oQ-i1XB8
----------------------------------------
About
----------------------------------------
Redux
	changes Flux Pattern
	ways to avoid complex flux bugs
.
When to use [what]...
React
	Building Component
	state in layout level component
		he's refering to his Layout Component, simple.
Flux
	App type
	stable in many ways.
Redux
	data complex scenarios/chain of events.
	takes longer than flux & frustrating.

NOW, Let look at DESIGNS
Flux
	it is a loop
		Components->Actions->Dispatcher->Stores
	Where 'Constants' connects Actions and Stores
Redux
	it is a loop
	[(Smart components)--"pass data as props"-->(Dumb component)]->Actions->[Reducer-notDispatcher]->[OneStore-notStores]->ProviderComponent--"Re-Render when store changes"
Actions
	Acts most like Flux
	triggered by components
	dispatch actions
	actions dispatch actions
	async action
		may dispatch FETCH_DATA, 
		RECIEVE_DATA when data comes in,
		FETCH_DATA_ERROR when error, 
Reducer/notDispatcher
	*multiple reducers mod immutably, concurrently(no racing conditions) on zero-dependent pieces of data
	instead of multiple stores that manage own data
	multiple reducers that all mod a "piece of data" from OneStore.
	mod immutable way.
	flux to redux thought
		instead of 3 stores, you got 3 reducers
		ex: data, settings, favorites
	all reducers can react to same Action
		all act at once 
		zero-dependency
OneStore
	1 BIG immutable store
		prior app - data, settings, favorites.
		now - dataList, settingList, favoritesList
	don't mutate, new versions of Store aka immutable.
		this way we have a full history.
ProviderComponent
	to wrap react app/components 
	listens to store.
Components
	[(Smart components)--"pass data as props"-->(Dumb component)]
	Smart
		Page level
		aware of framework
			know how to pull data from OneStore
		injects data into child properties
	Dumb
		//data manipulation level
		asks for data and splats data
.
Best Part of Redux
	OneStore version-ing
	Rollback capable
	Debug friendly
.
.
.
*****************************************
Video 16: Immutable JS - Redux Tutorial #2
*****************************************
https://youtu.be/9M-r8p9ey8U
----------------------------------------
About
----------------------------------------
immutability & mutation are topics of JS
*POS: Even of a programming doesn't have a feature, can write a way to provide that feature. 
immutable :: Don't change data, only create new data based on its values.
----------------------------------------
Info
----------------------------------------
immutable :: Don't change data, only create new data based on its values.
Why immutability not built into JS?
	2 types in JS
	1. primitive - they are their own -- immutable-ish
		numbers
		strings
		boolean
		?
			null
			undefined
		?
			objects
			array
		New in ES6
			Symbol
	2. reference - they are shared -- mutable
		object
		array
		functions 
ex:
//immutable
var a = 1; var b = a; b = 3; //a is the same
//mutable
var a = {num: 1}; var b = a; b.num = 2; //a is changed
//How to create immutable reference?
	Object.assign $.extend _.extend _.assign
ex:
//objects
	var a = {num: 1, val: 1}; var b = Object.assign({}, num, val, {etc: "something"}); b.num = 2; //a is same
//arrays
	//adding statically
	var a = [0, 1, 2]; var b = a.concat(3); //a is the same
	//removing statically
	var a = [0, 1, 2]; var b = a.filter((val)=>val!=2); //a is the same. filter out 2.
//mix?
var a = {num: 1, arr:[0, 1, 2]}; var b = Object.assign({}, num, a.arr.filter(2)); //a is same. created new obj and filtered out 2.
//others
	//map to change elems in array.
arr.map( ()=>{})
	//reduce reduces array to a single value with a function
		//requires total & currentValue
	//total is... initialVal or previous returned val
	//currentValue is... current elem
	//index is... index
	//arr is... arr
arr.reduce((total,currentValue, index,arr)=>{});
ex: arr.reduce((total,val)=>total+val); //total+=num;
----------------------------------------
Summary
----------------------------------------
always brings in new array/object.
	Object.assign({}, vars, to, pull);
	arr.concat(concatIn);
	arr.filter(filterOut);
	arr.map( (elem, i)=>{});
	arr.reduce((total,currentValue, index,arr)=>{});
.
*****************************************
Video 17: Basic Redux Introduction - Redux Tutorial #3
*****************************************
https://youtu.be/ucd5x3Ka3gw
----------------------------------------
About
----------------------------------------
Redux is SIMPLE, 
	BUT, when seeing a full example,
	it is hard to tell what is AcTuAlly making it work...
What we are doing?
	simple examples.
	then add the pieces.
	*See his source code repo.
`npm install redux`
Next time!
	separate following in to own files:
		REDUCER acts on STORE's DISPATCH and returns a state for SUBSCRIBED clients of certain store. 
----------------------------------------
Info -- redux
----------------------------------------
Not using react-basic files at all.
Will only use chrome developer tools to console.log().
Redux
	*is not a part/plugin of react.
	-own way of managing app state.
	-has its own style of flux framework.
	-can be used on any app 
	*just happens to work awesome with react.
		because, react is very functional
		*We will see why.
.
----------------------------------------
	file `client.js`
----------------------------------------
//to create redux Store, need 1 thing--a REDUCER.
import { createStore } from redux;
let initialState = 0; //{all vals of app state}
const reducer = function(state, action){
	if(action.type === "INC"){
		return state+1;
	}
	if(action.type === "DEC"){
		return state-1;
	}
	return state;
}
const store = createStore (reducer, initialState);


//listen to the store.
store.subscribe( ()=> {
	console.log("store changed", store.getState() );
});
//changes states based on actions
store.dispatch({ type:"INCREMENTS", payload: 1 });
store.dispatch({ type:"INCREMENTS", payload: 1 });
store.dispatch({ type:"INCREMENTS", payload: 1 });
store.dispatch({ type:"INCREMENTS", payload: 1 });
store.dispatch({ type:"DECREMENTS", payload: 1 });
	//REQUIRES object w/ type property



----------------------------------------
	Info - code `client.js`
----------------------------------------
//import one thing -- *createStore
	//to start a redux Store -- reducer function
	//*STORE needs (REDUCER, INITIAL STATE)
//listen to store and subscribe (print)
	//no console log..cause,
//dispatch events to store
	//can see store changed, but no state/nothing happened. 
	//cause, went through reducer()
		//was undefined
		//gets (state, action)
		//*return of reducer is new state of store
import { createStore } from redux;
store
	must be imported
	needs (reducer, initialState)
reducer
	gets to change states based on actions
	returns the new state
	needs (state{}/val, action{})
	maybe best place to put switch statement
dispatcher
	store.subscribe( ()=> {
		console.log("store changed", store.getState());
	});
//changes states based on actions
store.dispatch({ type:"INCREMENTS", payload: 1 });
Summary:
	store is the center. event is dispatched, reducer decides what/how to mod data and returns it, so client handles the output of subscribed store(can use store.getState() to do a certain action).
Presenter Summary:
	create a reducer, store, then whenever dispatch events...reducer(s), act upon store and client acts based on store's state.
.
.
.
----------------------------------------
Summary
----------------------------------------
What you need to use Redux
0. `npm install -S redux`
1. import createStore
2. 
3. 
4. 
5. 
6. 

Store is the center. Event is dispatched, reducer decides what/how to mod data and returns it, so client handles the output of subscribed store(can use store.getState() to do a certain action).

*****************************************
Video 18: Multiple Reducers - Redux/React Tutorial #4
*****************************************
https://youtu.be/gBER4Or86hE
----------------------------------------
About
----------------------------------------
We got, 
	BASIC REDUX app
	reducer, store w/ 1 val, 
	store.dispatch's and final subscribed component action.
Will do
	multiple reducers in own files
.
----------------------------------------

----------------------------------------



----------------------------------------

----------------------------------------



----------------------------------------
	file `client.js` EDIT
----------------------------------------
import {combineReducers, createStore} from redux;
//pretend reducers in own file.
const userReducer = (state={default:val}, actions) => {
	//const newState = {...state};
	switch(action.type){
		case "CHANGE_NAME": {
			//state.name = action.payload;
			state = {...state, name: action.payload}//...state must be before or changes will be overridden
			break;
		}
		case "CHANGE_AGE": {
			state.age = action.payload;
			break;
		}
	}
	return state;
	//return newState; //MUST BE A NEW STATE!
};
const tweetsReducer = (state={}, actions) => {

};
//passing object; what piece of data to which reducer will handle that data.
const reducer = combineReducers({
	user: userReducer
});
//**changed store reducer to combineReducers
const store = createStore(reducers, {
	user:{state: "dataHere"}, 
	tweets: [],
});
//pretend store subscription this line

//dispatches
store.dispatch({type: "CHANGE_NAME", payload: "Will"});
store.dispatch({type: "CHANGE_AGE", payload: 35});

----------------------------------------
About combineReducers line
----------------------------------------
When userReducer fires, 
	its state will be the Store's `user` prop/object
	the return value will be set for that same data fragment
Can place default values in respective reducers' params
DEFAULT values are crucial if want program not to crash/ERROR due to reducers' returning NOTHING.
.
EACH REDUCER MUST NOT MOD STATE - MUST BE immutable.
2 solutions
	1. new state
	2. mod w/ immutabile fashion. 
		Do this at same location of modding.
		NOTICE: ...state must be before, not after--or will revert to same state.
.
reducers 
	not aware of data fragment.
	multiple reducers can be triggered by one event
----------------------------------------
Summary:
----------------------------------------


.
.
.

*****************************************
Video 19: Redux Middleware - Redux Tutorial #5
*****************************************
https://youtu.be/DJ8fR0mZM44
----------------------------------------
About
----------------------------------------
Redux middle ware.
	One last thing to cover before React/Redux app.
	is like Express.js
	intercepts all actions
		can mod/cancel action
Will do now,
	Basic Middleware
Did now.
	rollback code to BASIC REDUX
Next Time,
	how middleware is solution to ASYNC actions.
		like ajax
		XHR requests
.
----------------------------------------
	code - `client.js`
----------------------------------------
import { applyMiddleware, createStore } from "redux";

const reducer = ( (initialState=0, action) => {
	//*edited
	else if(action.type === "E"){
		throw new Error("Gulp...!!");
	}
});

	//(probably won't need making middleware)
	//syntax for middleware uses `curry` format. 
	//most middleware can pull in as NPM package and use it by placing as params to applyMiddleware().
	//?chain of thumps/thunks? aka `curried` functions
	//**if not pass actions to next middleware, actions implements will terminate. I think subscription counts as middleware.
	//params. store, next-, action.
const logger = (store) => (next) => (action) => {
	console.log("action fired", action);
	//action.type = "DEC"; //will cause decrement even if fired INC
	next(action); //**REQUIRED!, passes to mw,reducers &subscription
}
//2nd middleware
const error = (store) => (next) => (action) => {
	try {
		next(action);
	}
	catch(e){
		console.log("OHH NOOO!", e);
	}
}

	//params-middleware want to add
const middleware = applyMiddleware(logger, error);

	//removed store subscription line. createStore 3rd-arg added--daMiddleware
	//to check if actually firing, but not called since middleware terminates wo/ passing actions to subscription
store.subscribe(()=>{
	console.log("store changed", store.getState());
});

	//3rd-arg--?do?
const store = createStore(reducer, 1, middleware);

store.dispatch({type: "INC"});
store.dispatch({type: "INC"});
store.dispatch({type: "DEC"});
store.dispatch({type: "DEC"});
store.dispatch({type: "INC"});
store.dispatch({type: "E"});
.
----------------------------------------
	Info on Code 
----------------------------------------
notice subscription was removed.
middleware
	setup
		is sometimes taken from NPM and just thrown into applyMiddleware() param..
		creating a middleware, curried functions (may/not be required)
		*place middleware into applyMiddleware() to make it an official middleware.
		createStore() 3rd-param is the applied Middleware.
	explained
		after dispatch/action fired,
			1st. middleware handles,
				middleware order matters. applyMiddleware 
				MUST PASS actions to others in series
					unless want to stop process.
					via next(action);
			2nd. reducers
			3rd. subscription
Examples for explanation purposes
ex: 1
	in logger middleware, 
		action.type = "DEC"
		overridden the action it would take by overwriting action.type, probably for each action that passed through.
	proves that middleware is between action dispatch and reducer
ex: 2
	in error middleware
		tried catching an error, which it can't unless one is throw.
		error is thrown in reducer, after middleware
		caught error
		console logged, reducer switch case, before middleware
		through out logs, 
			middleware was first and lastly subscribtion
			but in error, order was reducer, middleware, and subscription didn't occur.
			logger 1st, error 2nd.
	proves reducer may be first, middleware 2nd, but theory is best
	
**Best theory: error is considered an action and went through sequence again(middleware 1st). When, error passed to middleware, err log occurred instead of passing to subscription. Also, middleware order matters.
.
.
----------------------------------------
	Summary - Code
----------------------------------------
subscribe vs middleware timing
	?not sure?
subscribe
	does something for file subscribe to store, not/using newState provided by reducer via getState().
middleware
	*see code notes

To remember: 
	Store is the center. Event is dispatched, reducer decides what/how to mod data and returns it, so client handles the output of subscribed store(can use store.getState() to do a certain action).
.
.
.
----------------------------------------
----------------------------------------
SPIKE to JS videos....
	see `curry` functions
----------------------------------------
----------------------------------------

..................................
	Practice JS - Curry + more
..................................
https://www.youtube.com/watch?v=1DMolJ2FrNY&index=4&list=PL0zVEGEvSaeEd9hlmCXrk5yUyqUag-n84
------------------------------------
	sub-about
------------------------------------
In Immutable section we covered
	map, reduce, + others
We know, 
	recursion, promise, 
Will cover, 
	HOF - higher order functions
	reduce
	moar reduce
	closures
	currying
------------------------------------
	higher-order functions
------------------------------------
why, what how.
Why
	fun, better programmer, 
	less bugs-easy to reason
	less time-reuse more
	HOF-functions are values
		ex: var f = function(){}
	good for: composition.
		can decouple callbacks as own functions for 
			chaining methods like 
				filter, reject, find, map
----------------------------------------
	reduce
----------------------------------------
We know numbers only,
	but says can reduce into other value types
Presenter thoughts
	holy shit moment
	thought was for DB, noSQL DB...
	can use this everywhere, 
		even when you shouldn't
There are many array transformations!
What to do if not find one that fits?
	use REDUCE!
		can act as pre-built list transformer
.
This video was just EXTREMELY basic examples and doesn't showcase the POWER of reduce.
............
	code
............
var orders = [{amount: 250}, {amount: 400}, {amount: 100}, {amount: 325}];
var totalAmount = orders.reduce( (sum, order)=> sum + order.amount, 0);

----------------------------------------
	moar/more - reduce
----------------------------------------
About
	power of reduce
	how complies other list transformations
	can create complex objects
.
............
	code
............
reduce((accumulator, elems) => {	
}, {});
reduce((customers, customerInfo) => {	
	customers[customerInfo[0]] = customers[customerInfo[0]] || []; //without the OR arry in arr trick, would overwrite content and erase previous data.
	customers[customerInfo[0]].push({
		name:line[1], 
		price: line[2], 
		quantity: line[3],
	});	
	return customers;
}, {});
----------------------------------------
	closures
----------------------------------------
In JS, functions are functions and closures
closures
	function party has access to variables defined outside.
		This sounds like block vs function scope, particularly var.
In my exp
	start with minimal scope & variability, before opening up--is a good rule of thumb.
		const -> let -> var
Use cases to use closures aka function scope vars
	there is a few
	1. see sendRequest example
		request has access to certain data, even though is executed way later.
Info
	mozilla has great info about closures
	https://www.youtube.com/redirect?v=CQqwU2Ixu-U&event=video_description&q=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FClosures&redir_token=22vCeeAhZTcwwwWaxcWYr4Z4OkZ8MTUwNzA5Mjk3NUAxNTA3MDA2NTc1
About Code
	function really has access outside, doesn't snapshot variables.
............
	code
............
var me = 'Bruce Wayne';
function greetMe(){
	console.log('Hello', + me + '!');
}
me = 'Batman'; //line to prove snapshot idea
greetMe();
............
	sendRequest - closure example
............
	function sendRequest(){
		var requestID = '123';
		$ajax({
			url: '/myUrl',
			success: function(response){
				alert('Request ' + requestID + 'returned')
			}
		});
	}

----------------------------------------
	Currying - "Chain of thumps--redux vid".
----------------------------------------
Currying
	when a function not take all params upfront.
	provide arg for function, to return nth-arg for nth+function, where last function returns value wanted. currying of functions occur until, have all args needed.
		provide 1st-arg for function, to return a 2nd function w/ 2nd-arg, to return a function
			*due this until all args provided
			*last function, returns value wanted.
initial thoughts
	seems pointless
		more code
		does same
	but, is there some kind of async feature?
.
code info
	the idea of curry is...
		ur function can pass through app and gradually receive params
code summary
	gradual addition of elements, 
		requires to have inserted previous param, before calling shortened method for next param -- and so on...
............
	code
............
	//**regular
let dragon = (name, size, element) =>
	name + 'is a ' +
	size + 'dragon the breathes' +
	element + '!';
console.log(dragon('fluffykins', 'tiny', 'lightning'));
	//**curry format
let dragon = 
	name =>
		size=>
			element=>
				name + 'is a ' +
				size + 'dragon the breathes' +
				element + '!';
	//**whole print
console.log(dragon('fluffykins')('tiny')('lightning'));
	//**gradual data pickup.
let fluffykinsDragon = dragon('fluffykins');
let tinyDragon = fluffykins('tiny');
console.log(tinyDragon('lightning'));

	//**make non curry-able functions, curry-able
	//LODASH USED `npm install lodash`
import _ from "lodash";
let dragon = (name, size, element) =>
	name + 'is a ' +
	size + 'dragon the breathes' +
	element + '!';

	//note: not need lodash or libs as/for curry
dragon = _curry(dragon);
let fluffykinsDragon = dragon('fluffykins');
let tinyDragon = fluffykins('tiny');
console.log(tinyDragon('lightning'));

	//**example COMPLEX
let dragons = [
	{name: 'fluffykins', element: 'lightning'},
	{name: 'noomi', 	 element: 'lightning'},
	{name: 'karo', 		 element: 'fire'},
	{name: 'doomer', 	 element: 'timewarp'},
];
	//before
let hasElement =
	(element,obj)=>obj.element === element;
let lightningDragons = 
	dragon.filter(x => hasElement('lightning',x));
	//after - adding curry, removing wraping function.
let hasElement =
	_.curry( (element,obj)=>obj.element === element);
let lightningDragons = 
	dragon.filter(hasElement('lightning'));
console.log(lightningDragons);
.
Example summary
	**look at lightningDragons then hasElement
		curried in element first, then boolean of obj
.
----------------------------------------
	Recursions
----------------------------------------
Self Notes: 
	recursions should be simple, but think not cause, learned with BAD examples aka Fibonacci.
.
Recursion
	::calls itself, until it doesn't
	vs 
		while - don't know ending, but know when to stop.
		for - increment to a stopping point
		for, while, & recursion do the same, just diff context.
.
code
	//in words: take a number, say it, then take that number-1, say that, and follow that same rule. add stop condition.
Info
	covered what and how.
	why use it?
		*things recursion can do, that loops cannot
			*loops can get only if limited nesting...
				//I'm sure can get unknowing number of nesting - aka infinite.
				//something like:
					//STOP outside
					for(initial = input; stop; ){//stopMod//INCREMENT_RULE aka last state}
				//probably makes for loops look like recursion
.
............
	code - simple and mustUse
............
	//simple
let countDownFrom = (num) => {
	if(num === 0) return;
	console.log(num);
	countDownFrom(num-1);
}
countDownFrom(10);
	//mustUse - example where needed recursion
let categories = [
	{ id: 'animals', parent: null }, 
	{ id: 'mammals', parent: 'animals' }, 
	{ id: 'cats', parent': 'mammals' }, 
	{ id: 'dogs', parent': 'mammals' }, 
	{ id: 'chihuaha', parent': 'dogs' }, 
	{ id: 'labrador', parent': 'dogs' }, 
	{ id: 'persian', parent': 'cats' }, 
	{ id: 'siamese', parent': 'cats' }, 
];
//the idea is that the above is a tree. animals[[cats][dogs]]
//we know parent:null is unique and is root. Also, makes since root node will change last. Start at root, then go down.

function makeTree(categories, parent){ //INITIAL
	let node = {}; //STOP! //if nothing below, this is default.
	categories
		.filter((category) => 
			category.parent === parent)
		.forEach(category => 
			node[category.id] = makeTree(category, category.id)); //INCREMENT_RULE
	
	return makeTree(categories);
}
console.log(
	JSON.stringify(
		makeTree(categories, null)
		, null, 2)
	);
);

............
	code - recursion, for, while
............
	//**AS STOP - countTo**
		//recursion
var initial = 0; //INITIAL
function countTo(stop){ 
	if (initial > 10) { //STOP!
		return;
	}
	console.log(initial);
	return countTo(initial +1); //INCREMENT_RULE
}
		//for
var stop = prompt();
//INITIAL//STOP!//INCREMENT_RULE
for (int initial = 0; initial < stop; initial++){ 
	console.log(initial);
}
		//while
var stop = prompt();
var initial = 0;
while (initial < stop) {
	console.log(initial);
	initial++;
}
.
.
	//**AS INITIAL - countFrom**
		//recursion
function countFrom(initial){ //INITIAL
	if (!(initial<10 && initial>=0)){ //STOP!
		return; //initial ![0,10]
	}
	console.log(initial);
	return countFrom(initial+1); //INCREMENT_RULE
}
		//for
var _initial = prompt(); //INITIAL
//STOP! //INCREMENT_RULE
for (int initial = _initial; (initial<10&&initial>=0); initial++){
	console.log(initial);
}
		//while
initial = 0; //INITIAL
while (initial<10&&initial>=0) { //STOP!
	console.log(initial);
	initial++; //INCREMENT_RULE
}


SUMMARY - Recursion, For, while
I think a good tip is, 
	*initial is defined outside or passed as param!
	if we define initial, 
		code is inside
	if we DONT define initial, 
		it's defined outside.
.
.
.
**Add vids for JS above
.
.
.
----------------------------------------
----------------------------------------
jump back to video notes....
----------------------------------------
----------------------------------------
.
.
.
*****************************************
Video 20: Redux Async Actions - Redux Tutorial #6
*****************************************
https://youtu.be/Td-2D-_7Y2E
----------------------------------------
**About
----------------------------------------
Redux makes handling async actions easy!
	redux w/ react!
	*React is ONLY VIEW representation of the state of the store
		as store changes, view changes
	*never use state again, use props from store.
.
Next video
	Tie REDUX together with REACT
		async, etc.
.
----------------------------------------
	*Info-Code
----------------------------------------
in comments, said redux logger has changed!
	use this perhaps (check package)
	import { createLogger } from "redux-logger"; 
	const middleware = applyMiddleware(createLogger());
.
My suggestions
	try gathering reducers
	can make a generic reducer for most cases, and for special cases.
		no reason to repeat code with action types like this:
			FETCH_DATA_PENDING
			VS 
			FETCH_USERS_PENDING
			where only beginning is different.
.
Thunks
	dispatch single function, that receives dispatch param.
		*see store.dispatch( (dispatch)=>{} ); below
	thunks can only be given one argument.
middleware
	redux-logger
		helps to log in console with color coded info.
			beforeState, action, afterState
	thunk
		...
	redux-promise-middleware
		*great to clean up Promises.
			dispatch normally, w/ object aka action
			return promise as payload
		middleware will notice Promise payload in dispatch
			sends default messages/dispatches.
.
.			
----------------------------------------
	file `client.js` EDIT
----------------------------------------
//has reducer, applyMiddleware, store, subscription, dispatch
//axios//a XHR request//no need to bring in jquery
import {applyMiddleware, createStore} from "redux";
import axios from "axios";
import logger = from "redux-logger";
import thunk from "redux-thunk";
import promise from "redux-promise-middleware";


//has data UI can use
const initialState = {
	fetching: false, //if true, renders a loader tick
	fetched: false,
	users: [],
	error: null,
};

//with redux-promise-middleware, you get
	//type: "FETCH_USERS_PENDING"
	//type: "FETCH_USERS_FULFILLED"
	//type: "FETCH_USERS_REJECTED"
const reducer = ( (state=initialState, action) => {
	switch (action.type){
		case "FETCH_USERS_START":{
			return {...state, 
				fetching: true
			}
			break;
		}
		case "RECEIVE_USERS":{
			return {...state, 
				fetching: false, 
				fetched: true, 
				users: action.payload
			}
			break;
		}
		case "FETCH_USERS_ERROR":{
			return {...state, 
				fetching: false, 
				error: action.payload
			}
			break;
		}
		case "":{}
	}
	return state;
});

const middleware = applyMiddleware(promise(), thunk, logger()); //notice lgr()
const store = createStore(reducer, middleware);

//instead of store.dispatch({type: "FOO"});
//multiple actions in one action
//FETCH_USERS_START action wo/ payload, so UI can show loading bar.
//dispatch param - ?self?
//THUNK FORMAT
store.dispatch(dispatch => {
	dispatch({type: "FETCH_USERS_START"});
	//ASYNC!
	axios.get("http://rest.learncode.academy/api/wstern/users")
		.then((response) => {
			dispatch({type: "RECEIVE_USERS, payload: response.data});
		})
		.catch((err) => {
			dispatch({type: "FETCH_USERS_ERROR, payload: err});			
		});
	//do something Async.
	//dispatch({type: "FETCH_USERS_END"});
});


//REDUX-PROMISE-MIDDLEWARE FORMAT
store.dispatch({
	type: "FETCH_USERS", 
	payload: axios.get("http://rest.learncode.academy/api/wstern/users"), 
});
/* console.log default messages from rpm
type: "FETCH_USERS_PENDING"
type: "FETCH_USERS_FULFILLED"
type: "FETCH_USERS_REJECTED"
Change reducer action types to above mentioned.
*/
----------------------------------------
Summary
----------------------------------------


.
.
.
----------------------------------------
----------------------------------------
SPIKE to `Thunk`, `middleware`, `reduce-promise-middleware` & `data fetching and routing` videos....
----------------------------------------
----------------------------------------
.
.
.
----------------------------------------
About
----------------------------------------
What I know...
	-middleware 
		acts 1st after a dispatch before reducers and store subscription. 
	-in a flux design, you can design for asynch, but is a bit complicated.
	-redux gets a lot of the coding design done for you, but w/ appropriate redux packages.
	-
----------------------------------------
	Redux Thunk
----------------------------------------
https://www.youtube.com/watch?v=1QI-UE3-0PU
............
About
	redux plugin
	used to handle async action graders
Will talk about
	1. why thunk exists
	2. how to use redux thunk
Redux exists cause, 
	to hold app state.
	can change state in well defined pattern
Redux pattern. as suggested by Rally Coding.
	React--(user clicks something)
	-->Action Creator--(produces a...)
	-->Action--(flows into...)
	-->Middleware--(passes action to...)
	-->Reducers--(produces a...)
	-->State--(Flows into...)
	-->React
info on redux pattern
	nicely represents synchronous, not async
How do we make ASYNC requests?
	redux thunk
REDUX THUNK
	give direct control over dispatch method.
	dispatch is 
		a method from redux's store
		can be thought of / acts as
			handling middleware, reducers, state
			funnels actions to proper reducers
		a middleware (according to someone)
.		
............
	code - action file
............
import axios from 'axios';
export {
	fetchUsers: function(){
		const request = axios.get("http://jsonplaceholder.typicode.com/users");
		return(dispatch) => {
			request.then( ({data}) => {
				dispatch({type: 'FETCH_PROFILES', payload: data})
			});
		};
	},
};


............
	info - code 
............
actions file w/ 
functions
	returns data from promise requests
Thunk
	1st, realize existing rules for action creators go out the window. Think of it as funneling actions to reducers.
	vanilla redux expects to return action{}.
		return action{type: "required"}.
	redux Thunk enables one other return type, a JS function.
		return (dispatch)=>{
			//handleData into {}action for dispatch
		};
			think of it as a unique way to use thunk
.
Redux Thunk return
	reminder: 
		if we pass an action into dispatch, will be sent to all reducers.
		reducers will decide which action to act on, and return a state.
	*thunk has a special weird way to be called, 
		like passing dispatch itself into function...
		even though you never imported...
	*in the function, it promise.then() to dispatch action w/ data.
*WHAT IS HAPPENING behind the scenes?
	->App component is "calling, actionCreator, `fetchUsers`"
		whenever component about to mount `componentWillMount`, 
			it calls fetchUsers() actionCreator
	->"request to API" via axios
	->"fetchUsers returns function"
		usually, actionCreators expected to return action{}.
		redux-thunk, gives aditional return type (function()).
	->"RT" calls function w/dispatch
		redux-thunk:: which is our middleware
		*sees actionCreator returns a function, 
			automatically runs function with dispatch
	->"...time passes..."
		imagine sitting in function waiting for promises.
		think of it as sitting before the `.then()`.
	->"request resolves" some time in the future w/ data.
	->"call dispatch w/ action"
	->
redux-promise-middleware
	it knows that if action contains a promise, that it should wait.
.
			

.
.
----------------------------------------
ReactCasts #6 - Redux Middleware
----------------------------------------
https://www.youtube.com/watch?v=T-qtHI1qHIg
............
This is best video
	explains some redux design
	how/where/whenExecutes of middleware
	cool barebone implementation of promise middleware

----------------------------------------

----------------------------------------




.
.
.
----------------------------------------
----------------------------------------
jump back to video notes....
----------------------------------------
----------------------------------------
.
.
.
*****************************************
Video 21: Connecting React & Redux - Redux Tutorial #7
*****************************************
https://youtu.be/nrg7zhgJd4w
----------------------------------------
About
----------------------------------------
*see github repo in '5-redux-react'

----------------------------------------
	Info - code
----------------------------------------
client.js
	is renderer
Layout component
	returns null //empty page
store.js
	middleware & store.
	imported reducers from a separate file.
		import reducer from "./reducers";
	*see reducers.js
reducers.js
	combineReducers from redux
	importing other reducers
		combineReducers({tweets, user,});
actions
	*must have a type
	tweetAction
	userAction
suggested
	import * as user from "userActions";
	//to be able to do this:
	user.fetchUser();
.
**When an where use @connect?
	smart components use connect
	pass as props to dumb components
**More you pass PROPS, 
	the HARDER it is to unit test React Components
How broke up Redux code?...---
.

----------------------------------------
	file `client.js` EDIT aka renderer
----------------------------------------
import { Provider } from "react-redux";
import store from "./store";

ReactDOM.render(
	<Provider store={store}>
		<Layout />
	</Provider>
	, app);
----------------------------------------
	file `Layout.js` EDIT
----------------------------------------
import { connect } from "react-redux";
import {fetchUser} from "userActions";
import {fetchTweets} from "tweetsActions";

@connect( (store) => {
	return {
		foo: 1, 
		user: store.user.user,
		userFetched: store.user.fetched, 
		tweets, store.tweets.tweets,
	};
});
export default class Layout extends React.Component {
	componentWillMount(){
		this.props.dispatch(fetchUser()); //fetchUser was hardcoded
	}
	
	fetchTweets(){
		this.props.dispatch(fetchUser());
	}
	
	render(){
		//console.log(this.props);
		//lets say if tweets not loaded, give button to load them.
		const {user, tweets} = this.props;
		if (!tweets.length){
			return (
			<button onClick={this.fetchTweets.bind(this)}>
				load tweets!
			</button>);
		}
		const mappedTweets = tweets.map((tweets)=><li>tweet.text</li>);
		return (
			<div>
				<h1>{user.name}</h1>
				<ul>
					{mappedTweets}
				</ul>
			</div>
		);
	}
}
----------------------------------------
	file `tweetAction.js` EDIT
----------------------------------------
//functions


----------------------------------------
	Info - code 
----------------------------------------
with inserting store prop in Provider. "react-redux".
	app tied to redux.
	any component, in chain, 
		can import data from redux store.
		and dispatch store actions.
.
connect from "react-redux"
	**cleans up from having to place props in JSX Layout Level.
	**can slice parts from store.
	*injects props into components
	*runs 2 functions
		a. gets store values as props
		b. 
	can place above components if, 
	transpiling w/ ES6.
	package.json
		babel-plugin-transform-decorators-legacy
	webpack.config.js
		in plugins, added "transform-decorators-legacy"
.
transform-decorators-legacy
	great way to wrap components
.
----------------------------------------
Summary:
----------------------------------------


*****************************************
*****************************************
	END OF REDUX/REACT
*****************************************
*****************************************
If want to learn react efficiently, cover
react design and code.
	try catching good practices with "list transformations"
	ex: map, reduce, filter, reject, find, concat, 
flux design, NOT CODE -- confusing.
Redux design and code.
.
.
.
.
.

*****************************************
Video 22: 
*****************************************


----------------------------------------

----------------------------------------



----------------------------------------

----------------------------------------



*****************************************
Video 23: 
*****************************************


----------------------------------------

----------------------------------------



----------------------------------------

----------------------------------------







==========================================

==========================================



*****************************************

*****************************************



----------------------------------------

----------------------------------------




==========================================

==========================================



*****************************************

*****************************************



----------------------------------------

----------------------------------------




==========================================

==========================================



*****************************************

*****************************************



----------------------------------------

----------------------------------------








=================================================
OVERVIEW OF VIDEOS 1-5
=================================================
Series: https://www.youtube.com/watch?v=MhkGQAoc7bc&list=PLoYCgNOIyGABj2GQSlDRjgvXtqfDxKm5b
GitHub: https://github.com/learncodeacademy/react-js-tutorials
****************
OV: preReact notes - ES6
****************
*see preReact notes
Functions
module require/imports
deconstruction
function vs block scope
	var vs let vs const
.
.
.
****************
OV: preReact notes - webpack
****************
*see preReact notes
	Browsers don't understand certain JS, but webpack with loaders, plugins, presets, etc. help convert certain JS into understandable Vanilla/Browser JS.
webpack [entryFile] [outputFile]
webpack --watch
	updates outputFile with changes of tracked files.
webpack-dev-server
	creates a server in localhost of the webpage
	--watch conducted to track changes and display them
BEST to include in npm run script
	"dev": 
		"./node_modules/.bin/webpack-dev-server --content-base src --inline --hot",
.
.
.
****************
OV: Video 01 - Intro & Workspace
****************
-Components are like elements
-Props are like attributes
*Rendering Engine is separate from React Syntax
	ex: <Component prop="value">
	*import React from "react";
	*import ReactDOM from "react-dom";
	-import Layout from "./components/Layout";
	const app = document.getElementById('app');
	-*ReactDOM.render(<Layout/>, app);
Class Files extend React Components{
	render() {
		return (
			<div> //needed for more than one tag containment.
				//-JSX
			</div>
		);
	}
}
.
.
.
****************
OV: Video 02 - Reactjs Components & Rendering
****************
*see OV video 01
*Components return exactly one DOM element.
	like HTML, elements have one parent DOM element.	
*if 1+ component/element, contain all in <div></div>
Render after component created.
	const app = document.getElementById("app");
	ReactDOM.render(<Layout/>, app);
Where to place logic?
	within methods of class React Component
		within render()
	NO vars in class itself
.
****************
OV: Video 03 - Multiple Components
****************
Main points
	1. import a component, use it as an element.
		in another component or for rendering
	2. export default components to be used elsewhere.
	3. where to place logic
		a. within methods of class React Component
			i. within render()
		b. NO vars in class itself
	
entryFile
	import React from "react";
	import ReactDOM from "react-dom";
	*import Layout from "./components/Layout"; //#1a
	const app = document.getElementById('app');
	*ReactDOM.render(<Layout/>, app); //#1c
Layout
	import React from "react.js"
	import Footer from "Footer.js";
	import Header from "Header.js";
	export default class Layout extends React //#2 Component{ //#3b //constructor, methods//#3a, render(//#3i){//w/ return(<Header /> <Footer />)}} //#1b

****************
OV: Video 04 - State & Props and Application Data
****************
* How Data is managed in React.
1st great feature of react.
	1. VIRTUAL DOM & PURPOSEFUL DOM updates
.
2 ways data gets handled +1.
	1. state
	2. props
	3. context - but, this is an advanced feature. Also, API is not stabilized. 
.
*Props & States are inherited by React Component
.
States
	*Default state value*
		this.state = null; //by default.
	*placed in a class's Constructor*
		this.state = { //manipulation
			var1: "string", 
			var2: "123", 
			var3: {v:"v1"} 
		};
	*This creates a var within state; 
	*does not override state itself, but does with var*
		this.state.var = "sup"; //manipulation
	*'this.setState' can be placed in a method*
		this.setState({ var: "have 1var instead" }, miliSec);
	*THIS is how you print the state object*
		{ JSON.stringify(this.state) }
	*deconstruction in render's return(//JSX)*
		{ this.state.var } //access
	
	*Manages a VIRTUAL DOM
		***when state changes on a component, component will re-render.
		-whenever React renders component tree, it looks for changes in Virtual DOM to actual DOM.
	*WHY IS IT GREAT!
		-JavaScript is fast, DOM is slow. 
		-like Java's StringBuilder, doesn't update until the changes have been made.
	WHAT IS REACT DOING BEHIND SCENES.
		*Can see affects by going into chrome's console, clicking `escape` opening `rendering` tab
			-enable paint flashing
		-Re-render everything, all the time, on any change, but only in JS, only touch DOM if something changed visually.
	MENTALLITY of STATE
		***state only gets used, if component has an internal value that only affects that component.
		-WHEN to use it?
			-If you have something that only affects a certain component
			*Otherwise use props.
.
Props
	this.props.[]
	:: Props are attributes+values that may/not be passed into React Components when creating an element [in the render's return(//JSX <Component props="value">)], regardless of the React Component's design that may/may not expect its existence of passage.
		render(){ return( <div> <Component prop={"value"} /> </div> ); }
	*like XML, can pass any attribute-value pair.
		The receiving component, may/not use it.
	*encourages linked/respective Inheritance & Modularity.*
		<Component prop={this.props.title} /> //!!!
.
MIX of states & props
	*see above state and prop sections
	<Component prop={ this.state.var }>
	WHAT HAPPENS?
		same.
		Since, DOM doesn't change unless a state changes and that state is respective to one Component, not of many. And core prop may change through continuous passage, but without state, if not used jointly...
			*Maybe, this allows for DOM update where root prop changes and notified via state location.
.
.
.
.
****************
OV: Video 05 - Events & Data Changes in React
****************
Summary: Methods can be passed and used, via binded function props. Can create real-time DOM manipulation by changing STATE -- due to React Render -- with SetSTATE, triggered by an EVENT from INPUT, where JS eventTrigger is placed on the input/etc. with a binded/attached function. 

**NEVER CHANGE props VALUE WTHIN RENDER - won't be able to change it via site**

Passing functions
	*Can PASS functions VIA PROPS, but make sure to BIND them. 
		*By binding, you are passing which function to call and where. ex: class A's function 1, not a replica of class A's function 1 within B.
		*Binding helps to not call in context of where it is being called -- this avoids calling functions that do not exist, where it was passed to.
.
(-) means tutorial edits and works.
(+) means from tutorial, but left there for better picture
(*) means my edits for better picture
ex: BELOW CODE IS MORE CORRECT THAN NOTES ON EVENTS ABOVE
	class A extends React Component{
		constructor (){
			super();
-			this.state = {
-				title: "Welcome",
*				varBind: "ChangeMe",
-			};
		}
-		changeTitle(title){
-			this.setState({ title });
-		}
*		handleThisA(e){
*			const title = e.target.value;
*			this.changeTitle(title); //this IS REQUIRED
*		} //MY-WAY to be JS event handled here
*		handleThatA(e){
*			const title = e.target.value;
*			changeTitle(title);
*		} //MY-WAY to be JS event handled in another component
		render(){
			return(
				<div>
*					<input onChange={ this.handleThisA.bind(this) } value="defaultValue" />
*-					<B changeTitle={this.changeTitle.bind(this)} title={this.state.title} handleThatA={this.handleThatA.bind(this)} varBind={this.state.varBind.bind(this)} /> //passing props; changeTitle(title), title, and my handleThatA(e). CANNNOT BIND A VARIABLE
				</div>
			);
		}
	}//class A
	class B extends React Component {
-		handleChange(e){
-			const title = e.target.value;
-			this.props.changeTitle(title); //changeTitle contains a setChange and will cause react tree to render.
-		}
		render(){
-+*			this.props.changeTitle("ChangeNow");//passed function executes
+*			this.props.varBind = "GotChanged";
			return(
-				<input onChange={this.handleChange.bind(this)} value={this.props.title} /> //INPUT#1 Handled with, in-class method. //imagine passing function to 'input' component, this is reason for binding--i think. //value is defaulted
*				//WILL THIS WORK AND IS BIND NEEDED? SINCE, handleThatA was binded in class A - YES!
*				<input onChange={this.props.handleThatA} value={this.props.title} /> //INPUT#2 Handled with, propped method, but binding, not sure of the affects... JUST CAREFUL WITH VALUE, ONLY SET VALUE INPUT IS CHANGING OR NOTHING.
			);
		}
	}//class B
.
-------------------------
Learned-Hypothesised-Tested-Results
-------------------------
HYPO
	I want to test events (in class and through binded function props) -- YES,
	see if bind is needed for functions that have already been binded before passing via props -- YES,
	I want to run function props -- YES,
	Cause I can call a certain component's function and run it in context of which component it belongs to,
	  Can I alter a component's variable by binding and passing via props and thus editing in context of the components IT belongs to? -NO YOU CANNOT
BONUS FIND - UNCHANGABLE, RENDER RESET
//passed function executes fine, but makes input nonEditable
	// this.props.changeTitle("ChangedNow");
//CANNOT CHANGE Component's own props values.
	// this.props.varBind = "GotChanged";
//HOWEVER, can change object & array contents. -- ES6 basically
//Note for input value attribute/props
	//CANNOT CHANGE if given a STRING.
	//**Must be the value, event is changing or empty.
	//REASON:
		//When a change occurs, for example through an event-then-changeState, Render executes and value is reset to value placed there.
.
.
.
****************
OV: Video 06
****************

TBD...

****************
OV: Video 07
****************


****************
OV: Video 08
****************


****************
OV: Video 09
****************


****************
OV: Video 10
****************






